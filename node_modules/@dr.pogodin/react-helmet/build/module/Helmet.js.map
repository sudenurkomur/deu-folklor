{"version":3,"file":"Helmet.js","names":["Children","use","useEffect","useId","REACT_TAG_MAP","TAG_NAMES","VALID_TAG_NAMES","Context","cloneProps","mergeProps","pushToPropArray","assertChildType","childType","nestedChildren","Error","includes","join","Array","isArray","getPropName","key","res","console","warn","reduceChildrenAndProps","props","item","Object","values","it","keys","p","forEach","children","child","undefined","childProps","value","entries","type","toString","assertStringChild","child2","error","BASE","base","BODY","bodyAttributes","FRAGMENT","HTML","htmlAttributes","LINK","META","NOSCRIPT","SCRIPT","innerHTML","STYLE","cssText","TITLE","titleAttributes","title","HEAD","bad","Helmet","context","id","update","clientApply"],"sources":["../../src/Helmet.ts"],"sourcesContent":["import {\n  type FunctionComponent,\n  type ReactElement,\n  type ReactNode,\n  Children,\n  use,\n  useEffect,\n  useId,\n} from 'react';\n\nimport { REACT_TAG_MAP, TAG_NAMES, VALID_TAG_NAMES } from './constants';\n\nimport { Context } from './Provider';\n\nimport type {\n  BaseProps,\n  BodyProps,\n  HelmetChildProps,\n  HelmetProps,\n  HtmlProps,\n  LinkProps,\n  MetaProps,\n  NoscriptProps,\n  ScriptProps,\n  StyleProps,\n  TitleProps,\n} from './types';\nimport { cloneProps, mergeProps, pushToPropArray } from './utils';\n\nfunction assertChildType(\n  childType: ReactElement['type'],\n  nestedChildren: ReactNode,\n): asserts childType is TAG_NAMES {\n  if (typeof childType !== 'string') {\n    throw Error(\n      'You may be attempting to nest <Helmet> components within each other, which is not allowed. Refer to our API for more information.',\n    );\n  }\n\n  if (!(VALID_TAG_NAMES as string[]).includes(childType)) {\n    throw Error(\n      `Only elements types ${VALID_TAG_NAMES.join(', ')} are allowed. Helmet does not support rendering <${childType}> elements. Refer to our API for more information.`,\n    );\n  }\n\n  if (\n    !nestedChildren\n    || typeof nestedChildren === 'string'\n    || Array.isArray(nestedChildren)\n    // TODO: This piece of the check is wrong when parent is a fragment,\n    // and thus children may not be an array of strings.\n    // && nestedChildren.every((item) => typeof item === 'string')\n  ) return;\n\n  throw Error(\n    `Helmet expects a string as a child of <${childType}>. Did you forget to wrap your children in braces? ( <${childType}>{\\`\\`}</${childType}> ) Refer to our API for more information.`,\n  );\n}\n\n/**\n * Given a string key, it checks it against the legacy mapping between supported\n * HTML attribute names and their corresponding React prop names (for the names\n * that are different). If found in the mapping, it prints a warning to console\n * and returns the mapped prop name. Otherwise, it just returns the key as is,\n * assuming it is already a valid React prop name.\n */\nfunction getPropName(key: string): keyof HelmetChildProps {\n  const res = REACT_TAG_MAP[key];\n  if (res) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      `\"${key}\" is not a valid JSX prop, replace it by \"${res}\"`,\n    );\n  }\n  return (res ?? key) as keyof HelmetChildProps;\n}\n\n/**\n * Given children and props of a <Helmet> component, it reduces them to a single\n * props object.\n *\n * TODO: I guess, it should be further refactored, to make it cleaner...\n * though, it should perfectly work as is, so not a huge priority for now.\n */\nfunction reduceChildrenAndProps(props: HelmetProps): Omit<HelmetProps, 'children'> {\n  // NOTE: `props` are clonned, thus it is safe to push additional items to\n  // array values of `res`, and to re-assign non-array values of `res`, without\n  // the risk to mutate the original `props` object.\n  const res: HelmetProps = cloneProps(props);\n\n  // TODO: This is a temporary block, for compatibility with legacy library.\n  for (const item of Object.values(props)) {\n    if (Array.isArray(item)) {\n      for (const it of item) {\n        // TODO: This condition is actually needed to prevent some test failures,\n        // I guess, something is messed up with related types?\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (it) {\n          for (const key of Object.keys(it)) {\n            const p = getPropName(key);\n            if (p !== key) {\n              it[p] = it[key as keyof HelmetChildProps] as unknown;\n              delete it[key as keyof HelmetChildProps];\n            }\n          }\n        }\n      }\n    } else if (item && typeof item === 'object') {\n      const it = item as HelmetChildProps;\n      for (const key of Object.keys(it)) {\n        const p = getPropName(key);\n        if (p !== key) {\n          it[p] = it[key as keyof HelmetChildProps] as unknown;\n          delete it[key as keyof HelmetChildProps];\n        }\n      }\n    }\n  }\n\n  // eslint-disable-next-line complexity\n  Children.forEach(props.children, (child) => {\n    if (child === undefined || child === null) return;\n\n    if (typeof child !== 'object' || !('props' in child)) {\n      throw Error(\n        `\"${typeof child}\" is not a valid <Helmet> descendant`,\n      );\n    }\n\n    let nestedChildren: ReactNode;\n    const childProps: HelmetChildProps = {};\n    if (child.props) {\n      for (const [key, value] of Object.entries(child.props)) {\n        if (key === 'children') nestedChildren = value as ReactNode;\n        else childProps[getPropName(key)] = value as unknown;\n      }\n    }\n\n    let { type } = child;\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-conversion\n    if (typeof type === 'symbol') type = (type as 'symbol').toString();\n    assertChildType(type, nestedChildren);\n\n    function assertStringChild(child2: ReactNode): asserts child2 is string {\n      if (typeof child2 !== 'string') {\n        // TODO: We want to throw, but the legacy code did not, so we won't for\n        // now.\n        // eslint-disable-next-line no-console\n        console.error(`child of ${type as string} element should be a string`);\n\n        /*\n        throw Error(\n          // NOTE: assertChildType() above guarantees that `type` is a string,\n          // although it is not expressed in a way TypeScript can automatically\n          // pick up.\n        );\n        */\n      }\n    }\n\n    switch (type) {\n      case TAG_NAMES.BASE:\n        res.base = childProps as BaseProps;\n        break;\n\n      case TAG_NAMES.BODY:\n        res.bodyAttributes = childProps as BodyProps;\n        break;\n\n      case TAG_NAMES.FRAGMENT:\n        mergeProps(res, reduceChildrenAndProps({ children: nestedChildren }));\n        break;\n\n      case TAG_NAMES.HTML:\n        res.htmlAttributes = childProps as HtmlProps;\n        break;\n\n      case TAG_NAMES.LINK:\n      case TAG_NAMES.META:\n        if (nestedChildren) {\n          throw Error(\n            `<${type} /> elements are self-closing and can not contain children. Refer to our API for more information.`,\n          );\n        }\n        pushToPropArray(res, type, childProps as LinkProps | MetaProps);\n        break;\n\n      case TAG_NAMES.NOSCRIPT:\n      case TAG_NAMES.SCRIPT:\n        if (nestedChildren !== undefined) {\n          assertStringChild(nestedChildren);\n          (childProps as NoscriptProps | ScriptProps)\n            .innerHTML = nestedChildren;\n        }\n        pushToPropArray(res, type, childProps);\n        break;\n\n      case TAG_NAMES.STYLE:\n        assertStringChild(nestedChildren);\n        (childProps as StyleProps).cssText = nestedChildren;\n        pushToPropArray(res, type, childProps as StyleProps);\n        break;\n\n      case TAG_NAMES.TITLE:\n        res.titleAttributes = childProps as TitleProps;\n\n        if (typeof nestedChildren === 'string') res.title = nestedChildren;\n\n        // When title contains {} expressions the children are an array of\n        // strings, and other values.\n        else if (Array.isArray(nestedChildren)) res.title = nestedChildren.join('');\n        break;\n\n      case TAG_NAMES.HEAD:\n      default: {\n        // TODO: Perhaps, we should remove HEAD entry from TAG_NAMES?\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const bad: TAG_NAMES.HEAD = type;\n      }\n    }\n  });\n\n  delete res.children;\n  return res;\n}\n\nconst Helmet: FunctionComponent<HelmetProps> = (props) => {\n  const context = use(Context);\n\n  if (!context) {\n    throw Error(\n      '<Helmet> component must be within a <HelmetProvider> children tree',\n    );\n  }\n\n  const id = useId();\n\n  // TODO: Agh... we need it here to ensure that it works server-side,\n  // and we need the same in the useEffect() below to ensure it works\n  // client-side in strict mode (and, thus completely correctly from React's\n  // pure component / side effect logic). It clearly should be optimized,\n  // but let's care about it later.\n  context.update(id, reduceChildrenAndProps(props));\n\n  // TODO: I guess, these two useEffect() can be merged together, which should\n  // also allow to simplify and optimize the client-side management of attrs and\n  // elements managed by these. Though, keeping them separate is an easier way\n  // for now to ensure backward compatibility.\n  useEffect(() => {\n    context.update(id, reduceChildrenAndProps(props));\n    context.clientApply();\n  });\n\n  useEffect(() => () => {\n    context.update(id, undefined);\n    context.clientApply();\n  }, [context, id]);\n\n  return null;\n};\n\nexport default Helmet;\n"],"mappings":"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","ignoreList":[]}