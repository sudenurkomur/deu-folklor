import { createContext, useRef } from 'react';
import { newServerState } from './server';
import { IS_DOM_ENVIRONMENT } from './constants';
import { calcAggregatedState } from './utils';
import { commitTagChanges } from './client';
import { jsx as _jsx } from "react/jsx-runtime";
export const Context = /*#__PURE__*/createContext(undefined);
const HelmetProvider = ({
  children,
  context
}) => {
  const {
    current: heap
  } = useRef({
    firstRender: true,
    helmets: [],
    state: undefined
  });
  const contextValueRef = useRef(null);
  contextValueRef.current ??= {
    clientApply() {
      if (IS_DOM_ENVIRONMENT && !heap.state) {
        heap.state = calcAggregatedState(heap.helmets);
        if (heap.state.defer) {
          heap.nextAnimFrameId ??= requestAnimationFrame(() => {
            heap.state ??= calcAggregatedState(heap.helmets);
            commitTagChanges(heap.state, heap.firstRender);
            heap.firstRender = false;
            delete heap.nextAnimFrameId;
          });
        } else {
          if (heap.nextAnimFrameId !== undefined) {
            cancelAnimationFrame(heap.nextAnimFrameId);
            delete heap.nextAnimFrameId;
          }
          commitTagChanges(heap.state, heap.firstRender);
          heap.firstRender = false;
        }
      }
    },
    update(id, props) {
      const idx = heap.helmets.findIndex(item => item[0] === id);
      if (idx >= 0) {
        delete heap.state;
        if (props) heap.helmets[idx][1] = props;else heap.helmets.splice(idx, 1);
      } else if (props) {
        delete heap.state;
        heap.helmets.push([id, props]);
      }
    }
  };
  if (context && (!context.helmet || context.helmet !== heap.serverState)) {
    heap.serverState ??= newServerState(heap);

    // eslint-disable-next-line no-param-reassign
    context.helmet = heap.serverState;
  }
  return /*#__PURE__*/_jsx(Context, {
    value: contextValueRef.current,
    children: children
  });
};
export default HelmetProvider;
//# sourceMappingURL=Provider.js.map