import {
  require_jsx_runtime
} from "./chunk-R535KVNV.js";
import {
  require_react
} from "./chunk-PD3NECQZ.js";
import {
  __toESM
} from "./chunk-DC5AMYBS.js";

// node_modules/@dr.pogodin/react-helmet/build/module/Helmet.js
var import_react3 = __toESM(require_react());

// node_modules/@dr.pogodin/react-helmet/build/module/constants.js
var TAG_PROPERTIES = function(TAG_PROPERTIES2) {
  TAG_PROPERTIES2["CHARSET"] = "charset";
  TAG_PROPERTIES2["CSS_TEXT"] = "cssText";
  TAG_PROPERTIES2["HREF"] = "href";
  TAG_PROPERTIES2["HTTPEQUIV"] = "http-equiv";
  TAG_PROPERTIES2["INNER_HTML"] = "innerHTML";
  TAG_PROPERTIES2["ITEM_PROP"] = "itemprop";
  TAG_PROPERTIES2["NAME"] = "name";
  TAG_PROPERTIES2["PROPERTY"] = "property";
  TAG_PROPERTIES2["REL"] = "rel";
  TAG_PROPERTIES2["SRC"] = "src";
  return TAG_PROPERTIES2;
}({});
var ATTRIBUTE_NAMES = function(ATTRIBUTE_NAMES2) {
  ATTRIBUTE_NAMES2["BODY"] = "bodyAttributes";
  ATTRIBUTE_NAMES2["HTML"] = "htmlAttributes";
  ATTRIBUTE_NAMES2["TITLE"] = "titleAttributes";
  return ATTRIBUTE_NAMES2;
}({});
var TAG_NAMES = function(TAG_NAMES2) {
  TAG_NAMES2["BASE"] = "base";
  TAG_NAMES2["BODY"] = "body";
  TAG_NAMES2["HEAD"] = "head";
  TAG_NAMES2["HTML"] = "html";
  TAG_NAMES2["LINK"] = "link";
  TAG_NAMES2["META"] = "meta";
  TAG_NAMES2["NOSCRIPT"] = "noscript";
  TAG_NAMES2["SCRIPT"] = "script";
  TAG_NAMES2["STYLE"] = "style";
  TAG_NAMES2["TITLE"] = "title";
  TAG_NAMES2["FRAGMENT"] = "Symbol(react.fragment)";
  return TAG_NAMES2;
}({});
var SEO_PRIORITY_TAGS = {
  link: {
    rel: ["amphtml", "canonical", "alternate"]
  },
  meta: {
    charset: "",
    name: ["generator", "robots", "description"],
    property: ["og:type", "og:title", "og:url", "og:image", "og:image:alt", "og:description", "twitter:url", "twitter:title", "twitter:description", "twitter:image", "twitter:image:alt", "twitter:card", "twitter:site"]
  },
  script: {
    type: ["application/ld+json"]
  }
};
var VALID_TAG_NAMES = Object.values(TAG_NAMES);
var REACT_TAG_MAP = {
  accesskey: "accessKey",
  charset: "charSet",
  class: "className",
  contenteditable: "contentEditable",
  contextmenu: "contextMenu",
  "http-equiv": "httpEquiv",
  itemprop: "itemProp",
  tabindex: "tabIndex"
};
var HTML_TAG_MAP = (() => {
  const res = {};
  for (const [key, value] of Object.entries(REACT_TAG_MAP)) {
    res[value] = key;
  }
  return res;
})();
var HELMET_ATTRIBUTE = "data-rh";
var IS_DOM_ENVIRONMENT = !!(typeof window !== "undefined" && window.document.createElement);

// node_modules/@dr.pogodin/react-helmet/build/module/Provider.js
var import_react2 = __toESM(require_react());

// node_modules/@dr.pogodin/react-helmet/build/module/server.js
var import_react = __toESM(require_react());

// node_modules/@dr.pogodin/react-helmet/build/module/utils.js
function getInnermostProperty(props, propName) {
  for (let i = props.length - 1; i >= 0; --i) {
    const value = props[i][1][propName];
    if (value !== void 0) return value;
  }
  return void 0;
}
function getTitleFromPropsList(props) {
  let innermostTitle = getInnermostProperty(props, TAG_NAMES.TITLE);
  const innermostTemplate = getInnermostProperty(props, "titleTemplate");
  if (Array.isArray(innermostTitle)) {
    innermostTitle = innermostTitle.join("");
  }
  if (innermostTemplate && innermostTitle) {
    return innermostTemplate.replace(/%s/g, () => innermostTitle);
  }
  const innermostDefaultTitle = getInnermostProperty(props, "defaultTitle");
  return (innermostTitle || innermostDefaultTitle) ?? void 0;
}
function mergeAttributes(element, props) {
  const res = {};
  for (const item of props) {
    const attrs = item[1][element];
    if (attrs) Object.assign(res, attrs);
  }
  return res;
}
function aggregateBaseProps(props) {
  for (let i = props.length - 1; i >= 0; --i) {
    const res = props[i][1].base;
    if (res == null ? void 0 : res.href) return res;
  }
  return void 0;
}
function getPrimaryProp(props, primaryProps) {
  let primaryAttributeKey;
  for (const keyString of Object.keys(props)) {
    const key = keyString;
    if (primaryProps.includes(key) && !(primaryAttributeKey === TAG_PROPERTIES.REL && props[primaryAttributeKey].toLowerCase() === "canonical") && !(key === TAG_PROPERTIES.REL && props[key].toLowerCase() === "stylesheet")) primaryAttributeKey = key;
    if (primaryProps.includes(key) && (key === TAG_PROPERTIES.INNER_HTML || key === TAG_PROPERTIES.CSS_TEXT || key === TAG_PROPERTIES.ITEM_PROP)) primaryAttributeKey = key;
  }
  return primaryAttributeKey ?? null;
}
function getTagsFromPropsList(tagName, primaryAttributes, propsArray) {
  const approvedSeenTags = {};
  return propsArray.map(([, props]) => props).filter((props) => {
    if (Array.isArray(props[tagName])) {
      return true;
    }
    if (typeof props[tagName] !== "undefined") {
      console.warn(`Helmet: ${tagName} should be of type "Array". Instead found type "${typeof props[tagName]}"`);
    }
    return false;
  }).map((props) => props[tagName]).reverse().reduce((approvedTags, instanceTags) => {
    const instanceSeenTags = {};
    instanceTags.filter((tag) => {
      const primaryAttributeKey = getPrimaryProp(tag, primaryAttributes);
      if (!primaryAttributeKey || !tag[primaryAttributeKey]) {
        return false;
      }
      const value = tag[primaryAttributeKey].toLowerCase();
      if (!approvedSeenTags[primaryAttributeKey]) {
        approvedSeenTags[primaryAttributeKey] = {};
      }
      if (!instanceSeenTags[primaryAttributeKey]) {
        instanceSeenTags[primaryAttributeKey] = {};
      }
      if (!approvedSeenTags[primaryAttributeKey][value]) {
        instanceSeenTags[primaryAttributeKey][value] = true;
        return true;
      }
      return false;
    }).reverse().forEach((tag) => approvedTags.push(tag));
    const keys = Object.keys(instanceSeenTags);
    for (const attributeKey of keys) {
      const tagUnion = {
        ...approvedSeenTags[attributeKey],
        ...instanceSeenTags[attributeKey]
      };
      approvedSeenTags[attributeKey] = tagUnion;
    }
    return approvedTags;
  }, []).reverse();
}
function getAnyTrueFromPropsArray(propsArray, propName) {
  for (const [, props] of propsArray) {
    if (props[propName]) return true;
  }
  return false;
}
function flattenArray(possibleArray) {
  return Array.isArray(possibleArray) ? possibleArray.join("") : possibleArray;
}
function checkIfPropsMatch(props, toMatch) {
  var _a;
  for (const key of Object.keys(props)) {
    if ((_a = toMatch[key]) == null ? void 0 : _a.includes(props[key])) return true;
  }
  return false;
}
function prioritizer(propsArray, propsToMatch) {
  const res = {
    default: Array(),
    priority: Array()
  };
  if (propsArray) {
    for (const props of propsArray) {
      if (checkIfPropsMatch(props, propsToMatch)) {
        res.priority.push(props);
      } else {
        res.default.push(props);
      }
    }
  }
  return res;
}
function cloneProps(props) {
  const res = {};
  for (const [key, value] of Object.entries(props)) {
    res[key] = Array.isArray(value) ? value.slice() : value;
  }
  return res;
}
function mergeProps(target, source) {
  const tgt = target;
  for (const [key, srcValue] of Object.entries(source)) {
    if (Array.isArray(srcValue)) {
      const tgtValue = tgt[key];
      tgt[key] = tgtValue ? tgtValue.concat(srcValue) : srcValue;
    } else tgt[key] = srcValue;
  }
}
function pushToPropArray(target, array, item) {
  const tgt = target[array];
  if (tgt) tgt.push(item);
  else target[array] = [item];
}
function calcAggregatedState(props) {
  let links = getTagsFromPropsList(TAG_NAMES.LINK, [TAG_PROPERTIES.REL, TAG_PROPERTIES.HREF], props);
  let meta = getTagsFromPropsList("meta", [
    // NOTE: In the legacy version "charSet", "httpEquiv", and "itemProp"
    // were given as HTML attributes: charset, http-equiv, itemprop.
    // I believe, it is already fine to replace them here now, but
    // let's be vigilant.
    TAG_PROPERTIES.NAME,
    "charSet",
    "httpEquiv",
    TAG_PROPERTIES.PROPERTY,
    "itemProp"
  ], props);
  let script = getTagsFromPropsList("script", [TAG_PROPERTIES.SRC, TAG_PROPERTIES.INNER_HTML], props);
  const prioritizeSeoTags = getAnyTrueFromPropsArray(props, "prioritizeSeoTags");
  let priority;
  if (prioritizeSeoTags) {
    const linkP = prioritizer(links, SEO_PRIORITY_TAGS.link);
    links = linkP.default;
    const metaP = prioritizer(meta, SEO_PRIORITY_TAGS.meta);
    meta = metaP.default;
    const scriptP = prioritizer(script, SEO_PRIORITY_TAGS.script);
    script = scriptP.default;
    priority = {
      links: linkP.priority,
      meta: metaP.priority,
      script: scriptP.priority
    };
  }
  return {
    base: aggregateBaseProps(props),
    bodyAttributes: mergeAttributes("bodyAttributes", props),
    defer: getInnermostProperty(props, "defer"),
    encodeSpecialCharacters: getInnermostProperty(props, "encodeSpecialCharacters") ?? true,
    htmlAttributes: mergeAttributes("htmlAttributes", props),
    links,
    meta,
    noscript: getTagsFromPropsList("noscript", [TAG_PROPERTIES.INNER_HTML], props),
    onChangeClientState: getInnermostProperty(props, "onChangeClientState"),
    priority,
    script,
    style: getTagsFromPropsList("style", [TAG_PROPERTIES.CSS_TEXT], props),
    title: getTitleFromPropsList(props),
    titleAttributes: mergeAttributes("titleAttributes", props)
  };
}
function propToAttr(prop) {
  return HTML_TAG_MAP[prop] ?? prop;
}

// node_modules/@dr.pogodin/react-helmet/build/module/server.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var SELF_CLOSING_TAGS = [TAG_NAMES.NOSCRIPT, TAG_NAMES.SCRIPT, TAG_NAMES.STYLE];
var encodeSpecialCharacters = (str, encode = true) => {
  if (!encode) return str;
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
};
function generateElementAttributesAsString(attrs) {
  let res = "";
  for (const [name, value] of Object.entries(attrs)) {
    const attr = propToAttr(name);
    const neu = value === void 0 ? attr : `${attr}="${value}"`;
    if (neu && res) res += " ";
    res += neu;
  }
  return res;
}
var generateTitleAsString = (title, attrs, encode) => {
  let attrsStr = generateElementAttributesAsString(attrs);
  if (attrsStr) attrsStr = ` ${attrsStr}`;
  const flattenedTitle = flattenArray(title);
  return `<title ${HELMET_ATTRIBUTE}="true"${attrsStr}>${encodeSpecialCharacters(flattenedTitle, encode)}</title>`;
};
function generateTagsAsString(type, tags, encode) {
  let res = "";
  for (const tag of tags) {
    let attributeHtml = "";
    const entries = Object.entries(tag);
    for (const [name, value] of entries) {
      if (!(name === TAG_PROPERTIES.INNER_HTML || name === TAG_PROPERTIES.CSS_TEXT)) {
        const attrName = HTML_TAG_MAP[name] ?? name;
        let attr;
        if (value === void 0) attr = attrName;
        else {
          const valStr = typeof value === "string" ? value : String(value);
          attr = `${attrName}="${encodeSpecialCharacters(valStr, encode)}"`;
        }
        if (attributeHtml) attributeHtml += ` ${attr}`;
        else attributeHtml = attr;
      }
    }
    const tagContent = tag.innerHTML ?? tag.cssText ?? "";
    const isSelfClosing = !SELF_CLOSING_TAGS.includes(type);
    res += `<${type} ${HELMET_ATTRIBUTE}="true" ${attributeHtml}${isSelfClosing ? "/>" : `>${tagContent}</${type}>`}`;
  }
  return res;
}
function mapElementAttributesToProps(attributes, ops = {}) {
  const res = {};
  if (ops.addHelmetDataAttr) res[HELMET_ATTRIBUTE] = true;
  if (ops.addKey !== void 0) res.key = ops.addKey;
  for (const [attrName, value] of Object.entries(attributes)) {
    const propName = REACT_TAG_MAP[attrName] ?? attrName;
    switch (propName) {
      case "cssText":
      case "innerHTML":
        res.dangerouslySetInnerHTML = {
          __html: value
        };
        break;
      default:
        res[propName] = value;
    }
  }
  return res;
}
function renderTitle(title, attrs) {
  return [(0, import_jsx_runtime.jsx)("title", {
    ...mapElementAttributesToProps(attrs, {
      addHelmetDataAttr: true
    }),
    children: title
  }, title)];
}
function renderElement(type, attrs, key) {
  return (0, import_react.createElement)(type, mapElementAttributesToProps(attrs, {
    addHelmetDataAttr: true,
    addKey: key
  }));
}
function renderElements(type, attrs) {
  const res = [];
  for (let i = 0; i < attrs.length; ++i) {
    res.push(renderElement(type, attrs[i], i));
  }
  return res;
}
function newServerState(heap) {
  const getState = () => {
    heap.state ?? (heap.state = calcAggregatedState(heap.helmets));
    return heap.state;
  };
  return {
    base: {
      toComponent() {
        const props = getState().base;
        return props ? renderElements("base", [props]) : [];
      },
      toString() {
        const s = getState();
        return s.base ? generateTagsAsString("base", [s.base], s.encodeSpecialCharacters) : "";
      }
    },
    bodyAttributes: {
      toComponent() {
        const props = getState().bodyAttributes;
        return mapElementAttributesToProps(props ?? {});
      },
      toString() {
        const props = getState().bodyAttributes;
        return generateElementAttributesAsString(props ?? {});
      }
    },
    htmlAttributes: {
      toComponent() {
        const props = getState().htmlAttributes;
        return mapElementAttributesToProps(props ?? {});
      },
      toString() {
        const props = getState().htmlAttributes;
        return generateElementAttributesAsString(props ?? {});
      }
    },
    link: {
      toComponent() {
        return renderElements("link", getState().links ?? []);
      },
      toString() {
        const s = getState();
        return generateTagsAsString("link", s.links ?? [], s.encodeSpecialCharacters);
      }
    },
    meta: {
      toComponent() {
        return renderElements("meta", getState().meta ?? []);
      },
      toString() {
        const s = getState();
        return generateTagsAsString("meta", s.meta ?? [], s.encodeSpecialCharacters);
      }
    },
    noscript: {
      toComponent() {
        return renderElements("noscript", getState().noscript ?? []);
      },
      toString() {
        const s = getState();
        return generateTagsAsString("noscript", s.noscript ?? [], s.encodeSpecialCharacters);
      }
    },
    priority: {
      toComponent() {
        var _a, _b, _c;
        const s = getState();
        return [...renderElements("meta", ((_a = s.priority) == null ? void 0 : _a.meta) ?? []), ...renderElements("link", ((_b = s.priority) == null ? void 0 : _b.links) ?? []), ...renderElements("script", ((_c = s.priority) == null ? void 0 : _c.script) ?? [])];
      },
      toString() {
        var _a, _b, _c;
        const s = getState();
        const meta = generateTagsAsString("meta", ((_a = s.priority) == null ? void 0 : _a.meta) ?? [], s.encodeSpecialCharacters);
        const link = generateTagsAsString("link", ((_b = s.priority) == null ? void 0 : _b.links) ?? [], s.encodeSpecialCharacters);
        const script = generateTagsAsString("script", ((_c = s.priority) == null ? void 0 : _c.script) ?? [], s.encodeSpecialCharacters);
        let res = meta;
        if (link) {
          if (res) res += " ";
          res += link;
        }
        if (script) {
          if (res) res += " ";
          res += script;
        }
        return res;
      }
    },
    script: {
      toComponent() {
        return renderElements("script", getState().script ?? []);
      },
      toString() {
        const s = getState();
        return generateTagsAsString("script", s.script ?? [], s.encodeSpecialCharacters);
      }
    },
    style: {
      toComponent() {
        return renderElements("style", getState().style ?? []);
      },
      toString() {
        const s = getState();
        return generateTagsAsString("style", s.style ?? [], s.encodeSpecialCharacters);
      }
    },
    title: {
      toComponent() {
        const s = getState();
        return renderTitle(s.title ?? "", s.titleAttributes ?? {});
      },
      toString() {
        const s = getState();
        return generateTitleAsString(s.title ?? "", s.titleAttributes ?? {}, s.encodeSpecialCharacters);
      }
    }
  };
}

// node_modules/@dr.pogodin/react-helmet/build/module/client.js
function updateTags(type, tags) {
  const headElement = document.head || document.querySelector(TAG_NAMES.HEAD);
  const tagNodes = headElement.querySelectorAll(`${type}[${HELMET_ATTRIBUTE}]`);
  const allTags = [];
  const oldTags = [...tagNodes];
  const newTags = [];
  for (const tag of tags) {
    const newElement = document.createElement(type);
    for (const [key, value] of Object.entries(tag)) {
      if (Object.prototype.hasOwnProperty.call(tag, key)) {
        const name = HTML_TAG_MAP[key] ?? key;
        if (name === TAG_PROPERTIES.INNER_HTML) {
          newElement.innerHTML = value;
        } else if (name === TAG_PROPERTIES.CSS_TEXT) {
          if (newElement.styleSheet) {
            newElement.styleSheet.cssText = tag.cssText;
          } else {
            newElement.appendChild(document.createTextNode(tag.cssText));
          }
        } else {
          newElement.setAttribute(name, value ?? "");
        }
      }
    }
    newElement.setAttribute(HELMET_ATTRIBUTE, "true");
    const attrs = {};
    for (const {
      name,
      value
    } of newElement.attributes) {
      attrs[name] = value;
    }
    allTags.push(attrs);
    for (let i = 0; ; ++i) {
      if (newElement.isEqualNode(oldTags[i])) {
        oldTags.splice(i, 1);
        break;
      }
      if (i >= oldTags.length) {
        newTags.push(newElement);
        break;
      }
    }
  }
  oldTags.forEach((tag) => {
    var _a;
    return (_a = tag.parentNode) == null ? void 0 : _a.removeChild(tag);
  });
  newTags.forEach((tag) => headElement.appendChild(tag));
  return {
    allTags,
    newTags,
    oldTags
  };
}
function updateAttributes(tagName, props) {
  const [elementTag] = document.getElementsByTagName(tagName);
  if (!elementTag) {
    return;
  }
  const helmetAttributeString = elementTag.getAttribute(HELMET_ATTRIBUTE);
  const helmetAttributes = helmetAttributeString ? helmetAttributeString.split(",") : [];
  const attributesToRemove = [...helmetAttributes];
  const attributeKeys = [];
  for (const prop of Object.keys(props)) {
    attributeKeys.push(HTML_TAG_MAP[prop] ?? prop);
  }
  for (const [key, value] of Object.entries(props)) {
    const attr = HTML_TAG_MAP[key] ?? key;
    if (elementTag.getAttribute(attr) !== value) {
      elementTag.setAttribute(attr, value ?? "");
    }
    if (!helmetAttributes.includes(attr)) {
      helmetAttributes.push(attr);
    }
    const indexToSave = attributesToRemove.indexOf(attr);
    if (indexToSave !== -1) {
      attributesToRemove.splice(indexToSave, 1);
    }
  }
  for (let i = attributesToRemove.length - 1; i >= 0; i -= 1) {
    elementTag.removeAttribute(attributesToRemove[i]);
  }
  if (helmetAttributes.length === attributesToRemove.length) {
    elementTag.removeAttribute(HELMET_ATTRIBUTE);
  } else if (elementTag.getAttribute(HELMET_ATTRIBUTE) !== attributeKeys.join(",")) {
    elementTag.setAttribute(HELMET_ATTRIBUTE, attributeKeys.join(","));
  }
}
function updateTitle(title, attributes) {
  if (title !== void 0 && document.title !== title) {
    document.title = flattenArray(title);
  }
  updateAttributes(TAG_NAMES.TITLE, attributes);
}
function commitTagChanges(newState, firstRender) {
  const {
    base,
    bodyAttributes,
    defer,
    htmlAttributes,
    links,
    meta,
    noscript,
    onChangeClientState,
    script,
    style,
    title,
    titleAttributes
  } = newState;
  updateAttributes(TAG_NAMES.BODY, bodyAttributes ?? {});
  updateAttributes(TAG_NAMES.HTML, htmlAttributes ?? {});
  updateTitle(title, titleAttributes);
  const tagUpdates = {
    baseTag: updateTags(TAG_NAMES.BASE, base ? [base] : []),
    linkTags: updateTags(TAG_NAMES.LINK, links ?? []),
    metaTags: updateTags(TAG_NAMES.META, meta ?? []),
    noscriptTags: updateTags(TAG_NAMES.NOSCRIPT, noscript ?? []),
    scriptTags: updateTags(TAG_NAMES.SCRIPT, script ?? []),
    styleTags: updateTags(TAG_NAMES.STYLE, style ?? [])
  };
  const resultTags = {
    baseTag: [],
    bodyAttributes: {},
    defer: defer ?? false,
    htmlAttributes: {},
    linkTags: [],
    metaTags: [],
    noscriptTags: [],
    onChangeClientState: onChangeClientState ?? (() => void 0),
    scriptTags: [],
    styleTags: [],
    title: title ?? "",
    titleAttributes: {}
  };
  const addedTags = {};
  const removedTags = {};
  Object.keys(tagUpdates).forEach((tagType) => {
    const {
      allTags,
      newTags,
      oldTags
    } = tagUpdates[tagType];
    resultTags[tagType] = allTags;
    if (newTags.length) {
      addedTags[tagType] = newTags;
    }
    if (oldTags.length) {
      removedTags[tagType] = tagUpdates[tagType].oldTags;
    }
  });
  if (firstRender || Object.keys(addedTags).length || Object.keys(removedTags).length) {
    onChangeClientState == null ? void 0 : onChangeClientState(resultTags, addedTags, removedTags);
  }
}

// node_modules/@dr.pogodin/react-helmet/build/module/Provider.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var Context = (0, import_react2.createContext)(void 0);
var HelmetProvider = ({
  children,
  context
}) => {
  const {
    current: heap
  } = (0, import_react2.useRef)({
    firstRender: true,
    helmets: [],
    state: void 0
  });
  const contextValueRef = (0, import_react2.useRef)(null);
  contextValueRef.current ?? (contextValueRef.current = {
    clientApply() {
      if (IS_DOM_ENVIRONMENT && !heap.state) {
        heap.state = calcAggregatedState(heap.helmets);
        if (heap.state.defer) {
          heap.nextAnimFrameId ?? (heap.nextAnimFrameId = requestAnimationFrame(() => {
            heap.state ?? (heap.state = calcAggregatedState(heap.helmets));
            commitTagChanges(heap.state, heap.firstRender);
            heap.firstRender = false;
            delete heap.nextAnimFrameId;
          }));
        } else {
          if (heap.nextAnimFrameId !== void 0) {
            cancelAnimationFrame(heap.nextAnimFrameId);
            delete heap.nextAnimFrameId;
          }
          commitTagChanges(heap.state, heap.firstRender);
          heap.firstRender = false;
        }
      }
    },
    update(id, props) {
      const idx = heap.helmets.findIndex((item) => item[0] === id);
      if (idx >= 0) {
        delete heap.state;
        if (props) heap.helmets[idx][1] = props;
        else heap.helmets.splice(idx, 1);
      } else if (props) {
        delete heap.state;
        heap.helmets.push([id, props]);
      }
    }
  });
  if (context && (!context.helmet || context.helmet !== heap.serverState)) {
    heap.serverState ?? (heap.serverState = newServerState(heap));
    context.helmet = heap.serverState;
  }
  return (0, import_jsx_runtime2.jsx)(Context, {
    value: contextValueRef.current,
    children
  });
};
var Provider_default = HelmetProvider;

// node_modules/@dr.pogodin/react-helmet/build/module/Helmet.js
function assertChildType(childType, nestedChildren) {
  if (typeof childType !== "string") {
    throw Error("You may be attempting to nest <Helmet> components within each other, which is not allowed. Refer to our API for more information.");
  }
  if (!VALID_TAG_NAMES.includes(childType)) {
    throw Error(`Only elements types ${VALID_TAG_NAMES.join(", ")} are allowed. Helmet does not support rendering <${childType}> elements. Refer to our API for more information.`);
  }
  if (!nestedChildren || typeof nestedChildren === "string" || Array.isArray(nestedChildren)) return;
  throw Error(`Helmet expects a string as a child of <${childType}>. Did you forget to wrap your children in braces? ( <${childType}>{\`\`}</${childType}> ) Refer to our API for more information.`);
}
function getPropName(key) {
  const res = REACT_TAG_MAP[key];
  if (res) {
    console.warn(`"${key}" is not a valid JSX prop, replace it by "${res}"`);
  }
  return res ?? key;
}
function reduceChildrenAndProps(props) {
  const res = cloneProps(props);
  for (const item of Object.values(props)) {
    if (Array.isArray(item)) {
      for (const it of item) {
        if (it) {
          for (const key of Object.keys(it)) {
            const p = getPropName(key);
            if (p !== key) {
              it[p] = it[key];
              delete it[key];
            }
          }
        }
      }
    } else if (item && typeof item === "object") {
      const it = item;
      for (const key of Object.keys(it)) {
        const p = getPropName(key);
        if (p !== key) {
          it[p] = it[key];
          delete it[key];
        }
      }
    }
  }
  import_react3.Children.forEach(props.children, (child) => {
    if (child === void 0 || child === null) return;
    if (typeof child !== "object" || !("props" in child)) {
      throw Error(`"${typeof child}" is not a valid <Helmet> descendant`);
    }
    let nestedChildren;
    const childProps = {};
    if (child.props) {
      for (const [key, value] of Object.entries(child.props)) {
        if (key === "children") nestedChildren = value;
        else childProps[getPropName(key)] = value;
      }
    }
    let {
      type
    } = child;
    if (typeof type === "symbol") type = type.toString();
    assertChildType(type, nestedChildren);
    function assertStringChild(child2) {
      if (typeof child2 !== "string") {
        console.error(`child of ${type} element should be a string`);
      }
    }
    switch (type) {
      case TAG_NAMES.BASE:
        res.base = childProps;
        break;
      case TAG_NAMES.BODY:
        res.bodyAttributes = childProps;
        break;
      case TAG_NAMES.FRAGMENT:
        mergeProps(res, reduceChildrenAndProps({
          children: nestedChildren
        }));
        break;
      case TAG_NAMES.HTML:
        res.htmlAttributes = childProps;
        break;
      case TAG_NAMES.LINK:
      case TAG_NAMES.META:
        if (nestedChildren) {
          throw Error(`<${type} /> elements are self-closing and can not contain children. Refer to our API for more information.`);
        }
        pushToPropArray(res, type, childProps);
        break;
      case TAG_NAMES.NOSCRIPT:
      case TAG_NAMES.SCRIPT:
        if (nestedChildren !== void 0) {
          assertStringChild(nestedChildren);
          childProps.innerHTML = nestedChildren;
        }
        pushToPropArray(res, type, childProps);
        break;
      case TAG_NAMES.STYLE:
        assertStringChild(nestedChildren);
        childProps.cssText = nestedChildren;
        pushToPropArray(res, type, childProps);
        break;
      case TAG_NAMES.TITLE:
        res.titleAttributes = childProps;
        if (typeof nestedChildren === "string") res.title = nestedChildren;
        else if (Array.isArray(nestedChildren)) res.title = nestedChildren.join("");
        break;
      case TAG_NAMES.HEAD:
      default: {
        const bad = type;
      }
    }
  });
  delete res.children;
  return res;
}
var Helmet = (props) => {
  const context = (0, import_react3.use)(Context);
  if (!context) {
    throw Error("<Helmet> component must be within a <HelmetProvider> children tree");
  }
  const id = (0, import_react3.useId)();
  context.update(id, reduceChildrenAndProps(props));
  (0, import_react3.useEffect)(() => {
    context.update(id, reduceChildrenAndProps(props));
    context.clientApply();
  });
  (0, import_react3.useEffect)(() => () => {
    context.update(id, void 0);
    context.clientApply();
  }, [context, id]);
  return null;
};
var Helmet_default = Helmet;

// node_modules/@dr.pogodin/react-helmet/build/module/MetaTags.js
var import_react4 = __toESM(require_react());
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var Context2 = (0, import_react4.createContext)({
  description: "",
  title: ""
});
var MetaTags = ({
  children,
  description,
  extraMetaTags,
  image,
  siteName,
  socialDescription,
  socialTitle,
  title,
  url
}) => {
  const socTitle = socialTitle || title;
  const socDesc = socialDescription || description;
  const context = (0, import_react4.useMemo)(() => ({
    description,
    image,
    siteName,
    socialDescription,
    socialTitle,
    title,
    url
  }), [description, image, siteName, socialDescription, socialTitle, title, url]);
  const extra = [];
  if (extraMetaTags == null ? void 0 : extraMetaTags.length) {
    for (let i = 0; i < extraMetaTags.length; ++i) {
      const {
        content,
        name
      } = extraMetaTags[i];
      extra.push((0, import_jsx_runtime3.jsx)("meta", {
        content,
        name
      }, `extra-meta-tag-${i}`));
    }
  }
  return (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, {
    children: [(0, import_jsx_runtime3.jsxs)(Helmet_default, {
      children: [(0, import_jsx_runtime3.jsx)("title", {
        children: title
      }), (0, import_jsx_runtime3.jsx)("meta", {
        content: description,
        name: "description"
      }), (0, import_jsx_runtime3.jsx)("meta", {
        content: "summary_large_image",
        name: "twitter:card"
      }), (0, import_jsx_runtime3.jsx)("meta", {
        content: socTitle,
        name: "twitter:title"
      }), (0, import_jsx_runtime3.jsx)("meta", {
        content: socDesc,
        name: "twitter:description"
      }), image ? (0, import_jsx_runtime3.jsx)("meta", {
        content: image,
        name: "twitter:image"
      }) : null, siteName ? (0, import_jsx_runtime3.jsx)("meta", {
        content: `@${siteName}`,
        name: "twitter:site"
      }) : null, (0, import_jsx_runtime3.jsx)("meta", {
        content: socTitle,
        name: "og:title"
      }), image ? (0, import_jsx_runtime3.jsx)("meta", {
        content: image,
        name: "og:image"
      }) : null, image ? (0, import_jsx_runtime3.jsx)("meta", {
        content: socTitle,
        name: "og:image:alt"
      }) : null, (0, import_jsx_runtime3.jsx)("meta", {
        content: socDesc,
        name: "og:description"
      }), siteName ? (0, import_jsx_runtime3.jsx)("meta", {
        content: siteName,
        name: "og:sitename"
      }) : null, url ? (0, import_jsx_runtime3.jsx)("meta", {
        content: url,
        name: "og:url"
      }) : null, extra]
    }), children ? (0, import_jsx_runtime3.jsx)(Context2, {
      value: context,
      children
    }) : null]
  });
};
MetaTags.Context = Context2;
var MetaTags_default = MetaTags;
export {
  Helmet_default as Helmet,
  Provider_default as HelmetProvider,
  MetaTags_default as MetaTags
};
//# sourceMappingURL=@dr__pogodin_react-helmet.js.map
