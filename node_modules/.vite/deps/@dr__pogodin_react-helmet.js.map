{
  "version": 3,
  "sources": ["../../@dr.pogodin/react-helmet/src/Helmet.ts", "../../@dr.pogodin/react-helmet/src/constants.ts", "../../@dr.pogodin/react-helmet/src/Provider.tsx", "../../@dr.pogodin/react-helmet/src/server.tsx", "../../@dr.pogodin/react-helmet/src/utils.ts", "../../@dr.pogodin/react-helmet/src/client.ts", "../../@dr.pogodin/react-helmet/src/MetaTags.tsx"],
  "sourcesContent": ["import {\n  type FunctionComponent,\n  type ReactElement,\n  type ReactNode,\n  Children,\n  use,\n  useEffect,\n  useId,\n} from 'react';\n\nimport { REACT_TAG_MAP, TAG_NAMES, VALID_TAG_NAMES } from './constants';\n\nimport { Context } from './Provider';\n\nimport type {\n  BaseProps,\n  BodyProps,\n  HelmetChildProps,\n  HelmetProps,\n  HtmlProps,\n  LinkProps,\n  MetaProps,\n  NoscriptProps,\n  ScriptProps,\n  StyleProps,\n  TitleProps,\n} from './types';\nimport { cloneProps, mergeProps, pushToPropArray } from './utils';\n\nfunction assertChildType(\n  childType: ReactElement['type'],\n  nestedChildren: ReactNode,\n): asserts childType is TAG_NAMES {\n  if (typeof childType !== 'string') {\n    throw Error(\n      'You may be attempting to nest <Helmet> components within each other, which is not allowed. Refer to our API for more information.',\n    );\n  }\n\n  if (!(VALID_TAG_NAMES as string[]).includes(childType)) {\n    throw Error(\n      `Only elements types ${VALID_TAG_NAMES.join(', ')} are allowed. Helmet does not support rendering <${childType}> elements. Refer to our API for more information.`,\n    );\n  }\n\n  if (\n    !nestedChildren\n    || typeof nestedChildren === 'string'\n    || Array.isArray(nestedChildren)\n    // TODO: This piece of the check is wrong when parent is a fragment,\n    // and thus children may not be an array of strings.\n    // && nestedChildren.every((item) => typeof item === 'string')\n  ) return;\n\n  throw Error(\n    `Helmet expects a string as a child of <${childType}>. Did you forget to wrap your children in braces? ( <${childType}>{\\`\\`}</${childType}> ) Refer to our API for more information.`,\n  );\n}\n\n/**\n * Given a string key, it checks it against the legacy mapping between supported\n * HTML attribute names and their corresponding React prop names (for the names\n * that are different). If found in the mapping, it prints a warning to console\n * and returns the mapped prop name. Otherwise, it just returns the key as is,\n * assuming it is already a valid React prop name.\n */\nfunction getPropName(key: string): keyof HelmetChildProps {\n  const res = REACT_TAG_MAP[key];\n  if (res) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      `\"${key}\" is not a valid JSX prop, replace it by \"${res}\"`,\n    );\n  }\n  return (res ?? key) as keyof HelmetChildProps;\n}\n\n/**\n * Given children and props of a <Helmet> component, it reduces them to a single\n * props object.\n *\n * TODO: I guess, it should be further refactored, to make it cleaner...\n * though, it should perfectly work as is, so not a huge priority for now.\n */\nfunction reduceChildrenAndProps(props: HelmetProps): Omit<HelmetProps, 'children'> {\n  // NOTE: `props` are clonned, thus it is safe to push additional items to\n  // array values of `res`, and to re-assign non-array values of `res`, without\n  // the risk to mutate the original `props` object.\n  const res: HelmetProps = cloneProps(props);\n\n  // TODO: This is a temporary block, for compatibility with legacy library.\n  for (const item of Object.values(props)) {\n    if (Array.isArray(item)) {\n      for (const it of item) {\n        // TODO: This condition is actually needed to prevent some test failures,\n        // I guess, something is messed up with related types?\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (it) {\n          for (const key of Object.keys(it)) {\n            const p = getPropName(key);\n            if (p !== key) {\n              it[p] = it[key as keyof HelmetChildProps] as unknown;\n              delete it[key as keyof HelmetChildProps];\n            }\n          }\n        }\n      }\n    } else if (item && typeof item === 'object') {\n      const it = item as HelmetChildProps;\n      for (const key of Object.keys(it)) {\n        const p = getPropName(key);\n        if (p !== key) {\n          it[p] = it[key as keyof HelmetChildProps] as unknown;\n          delete it[key as keyof HelmetChildProps];\n        }\n      }\n    }\n  }\n\n  // eslint-disable-next-line complexity\n  Children.forEach(props.children, (child) => {\n    if (child === undefined || child === null) return;\n\n    if (typeof child !== 'object' || !('props' in child)) {\n      throw Error(\n        `\"${typeof child}\" is not a valid <Helmet> descendant`,\n      );\n    }\n\n    let nestedChildren: ReactNode;\n    const childProps: HelmetChildProps = {};\n    if (child.props) {\n      for (const [key, value] of Object.entries(child.props)) {\n        if (key === 'children') nestedChildren = value as ReactNode;\n        else childProps[getPropName(key)] = value as unknown;\n      }\n    }\n\n    let { type } = child;\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-conversion\n    if (typeof type === 'symbol') type = (type as 'symbol').toString();\n    assertChildType(type, nestedChildren);\n\n    function assertStringChild(child2: ReactNode): asserts child2 is string {\n      if (typeof child2 !== 'string') {\n        // TODO: We want to throw, but the legacy code did not, so we won't for\n        // now.\n        // eslint-disable-next-line no-console\n        console.error(`child of ${type as string} element should be a string`);\n\n        /*\n        throw Error(\n          // NOTE: assertChildType() above guarantees that `type` is a string,\n          // although it is not expressed in a way TypeScript can automatically\n          // pick up.\n        );\n        */\n      }\n    }\n\n    switch (type) {\n      case TAG_NAMES.BASE:\n        res.base = childProps as BaseProps;\n        break;\n\n      case TAG_NAMES.BODY:\n        res.bodyAttributes = childProps as BodyProps;\n        break;\n\n      case TAG_NAMES.FRAGMENT:\n        mergeProps(res, reduceChildrenAndProps({ children: nestedChildren }));\n        break;\n\n      case TAG_NAMES.HTML:\n        res.htmlAttributes = childProps as HtmlProps;\n        break;\n\n      case TAG_NAMES.LINK:\n      case TAG_NAMES.META:\n        if (nestedChildren) {\n          throw Error(\n            `<${type} /> elements are self-closing and can not contain children. Refer to our API for more information.`,\n          );\n        }\n        pushToPropArray(res, type, childProps as LinkProps | MetaProps);\n        break;\n\n      case TAG_NAMES.NOSCRIPT:\n      case TAG_NAMES.SCRIPT:\n        if (nestedChildren !== undefined) {\n          assertStringChild(nestedChildren);\n          (childProps as NoscriptProps | ScriptProps)\n            .innerHTML = nestedChildren;\n        }\n        pushToPropArray(res, type, childProps);\n        break;\n\n      case TAG_NAMES.STYLE:\n        assertStringChild(nestedChildren);\n        (childProps as StyleProps).cssText = nestedChildren;\n        pushToPropArray(res, type, childProps as StyleProps);\n        break;\n\n      case TAG_NAMES.TITLE:\n        res.titleAttributes = childProps as TitleProps;\n\n        if (typeof nestedChildren === 'string') res.title = nestedChildren;\n\n        // When title contains {} expressions the children are an array of\n        // strings, and other values.\n        else if (Array.isArray(nestedChildren)) res.title = nestedChildren.join('');\n        break;\n\n      case TAG_NAMES.HEAD:\n      default: {\n        // TODO: Perhaps, we should remove HEAD entry from TAG_NAMES?\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const bad: TAG_NAMES.HEAD = type;\n      }\n    }\n  });\n\n  delete res.children;\n  return res;\n}\n\nconst Helmet: FunctionComponent<HelmetProps> = (props) => {\n  const context = use(Context);\n\n  if (!context) {\n    throw Error(\n      '<Helmet> component must be within a <HelmetProvider> children tree',\n    );\n  }\n\n  const id = useId();\n\n  // TODO: Agh... we need it here to ensure that it works server-side,\n  // and we need the same in the useEffect() below to ensure it works\n  // client-side in strict mode (and, thus completely correctly from React's\n  // pure component / side effect logic). It clearly should be optimized,\n  // but let's care about it later.\n  context.update(id, reduceChildrenAndProps(props));\n\n  // TODO: I guess, these two useEffect() can be merged together, which should\n  // also allow to simplify and optimize the client-side management of attrs and\n  // elements managed by these. Though, keeping them separate is an easier way\n  // for now to ensure backward compatibility.\n  useEffect(() => {\n    context.update(id, reduceChildrenAndProps(props));\n    context.clientApply();\n  });\n\n  useEffect(() => () => {\n    context.update(id, undefined);\n    context.clientApply();\n  }, [context, id]);\n\n  return null;\n};\n\nexport default Helmet;\n", "export enum TAG_PROPERTIES {\n  CHARSET = 'charset',\n  CSS_TEXT = 'cssText',\n  HREF = 'href',\n  HTTPEQUIV = 'http-equiv',\n  INNER_HTML = 'innerHTML',\n  ITEM_PROP = 'itemprop',\n  NAME = 'name',\n  PROPERTY = 'property',\n  REL = 'rel',\n  SRC = 'src',\n}\n\nexport enum ATTRIBUTE_NAMES {\n  BODY = 'bodyAttributes',\n  HTML = 'htmlAttributes',\n  TITLE = 'titleAttributes',\n}\n\nexport enum TAG_NAMES {\n  BASE = 'base',\n  BODY = 'body',\n  HEAD = 'head',\n  HTML = 'html',\n  LINK = 'link',\n  META = 'meta',\n  NOSCRIPT = 'noscript',\n  SCRIPT = 'script',\n  STYLE = 'style',\n  TITLE = 'title',\n  FRAGMENT = 'Symbol(react.fragment)',\n}\n\nexport const SEO_PRIORITY_TAGS = {\n  link: { rel: ['amphtml', 'canonical', 'alternate'] },\n  meta: {\n    charset: '',\n    name: ['generator', 'robots', 'description'],\n    property: [\n      'og:type',\n      'og:title',\n      'og:url',\n      'og:image',\n      'og:image:alt',\n      'og:description',\n      'twitter:url',\n      'twitter:title',\n      'twitter:description',\n      'twitter:image',\n      'twitter:image:alt',\n      'twitter:card',\n      'twitter:site',\n    ],\n  },\n  script: { type: ['application/ld+json'] },\n};\n\nexport const VALID_TAG_NAMES = Object.values(TAG_NAMES);\n\n/**\n * The mapping of HTML attribute names to the corresponding element properties,\n * for the names that do not match their corresponding properties.\n */\nexport const REACT_TAG_MAP: Record<string, string> = {\n  accesskey: 'accessKey',\n  charset: 'charSet',\n  class: 'className',\n  contenteditable: 'contentEditable',\n  contextmenu: 'contextMenu',\n  'http-equiv': 'httpEquiv',\n  itemprop: 'itemProp',\n  tabindex: 'tabIndex',\n};\n\n/**\n * The mapping reverse of REACT_TAG_MAP.\n */\nexport const HTML_TAG_MAP = (() => {\n  const res: Record<string, string> = {};\n  for (const [key, value] of Object.entries(REACT_TAG_MAP)) {\n    res[value] = key;\n  }\n  return res;\n})();\n\nexport const HELMET_ATTRIBUTE = 'data-rh';\n\nexport const IS_DOM_ENVIRONMENT = !!(\n  typeof window !== 'undefined'\n  && window.document.createElement\n);\n", "import {\n  type FunctionComponent,\n  type ReactNode,\n  createContext,\n  useRef,\n} from 'react';\n\nimport type {\n  ContextValue,\n  HelmetDataContext,\n  HelmetProps,\n  HelmetProviderHeap,\n} from './types';\n\nimport { newServerState } from './server';\nimport { IS_DOM_ENVIRONMENT } from './constants';\nimport { calcAggregatedState } from './utils';\nimport { commitTagChanges } from './client';\n\nexport const Context = createContext<ContextValue | undefined>(undefined);\n\ntype ProviderProps = {\n  children?: ReactNode;\n  context?: HelmetDataContext;\n};\n\nconst HelmetProvider: FunctionComponent<ProviderProps> = ({\n  children,\n  context,\n}) => {\n  const { current: heap } = useRef<HelmetProviderHeap>({\n    firstRender: true,\n    helmets: [],\n    state: undefined,\n  });\n\n  const contextValueRef = useRef<ContextValue>(null);\n\n  contextValueRef.current ??= {\n    clientApply() {\n      if (IS_DOM_ENVIRONMENT && !heap.state) {\n        heap.state = calcAggregatedState(heap.helmets);\n        if (heap.state.defer) {\n          heap.nextAnimFrameId ??= requestAnimationFrame(() => {\n            heap.state ??= calcAggregatedState(heap.helmets);\n            commitTagChanges(heap.state, heap.firstRender);\n            heap.firstRender = false;\n            delete heap.nextAnimFrameId;\n          });\n        } else {\n          if (heap.nextAnimFrameId !== undefined) {\n            cancelAnimationFrame(heap.nextAnimFrameId);\n            delete heap.nextAnimFrameId;\n          }\n          commitTagChanges(heap.state, heap.firstRender);\n          heap.firstRender = false;\n        }\n      }\n    },\n    update(id: string, props: HelmetProps | undefined) {\n      const idx = heap.helmets.findIndex((item) => item[0] === id);\n      if (idx >= 0) {\n        delete heap.state;\n        if (props) heap.helmets[idx]![1] = props;\n        else heap.helmets.splice(idx, 1);\n      } else if (props) {\n        delete heap.state;\n        heap.helmets.push([id, props]);\n      }\n    },\n  };\n\n  if (context && (!context.helmet || context.helmet !== heap.serverState)) {\n    heap.serverState ??= newServerState(heap);\n\n    // eslint-disable-next-line no-param-reassign\n    context.helmet = heap.serverState;\n  }\n\n  return <Context value={contextValueRef.current}>{children}</Context>;\n};\n\nexport default HelmetProvider;\n", "import {\n  type HTMLAttributes,\n  type Key,\n  type ReactNode,\n  createElement,\n} from 'react';\n\nimport {\n  HELMET_ATTRIBUTE,\n  TAG_NAMES,\n  REACT_TAG_MAP,\n  TAG_PROPERTIES,\n  HTML_TAG_MAP,\n} from './constants';\n\nimport type {\n  HelmetProviderHeap,\n  HelmetServerState,\n  ScriptProps,\n  StyleProps,\n  TitleProps,\n} from './types';\n\nimport {\n  calcAggregatedState,\n  flattenArray,\n  propToAttr,\n} from './utils';\n\nconst SELF_CLOSING_TAGS: string[] = [\n  TAG_NAMES.NOSCRIPT,\n  TAG_NAMES.SCRIPT,\n  TAG_NAMES.STYLE,\n];\n\nconst encodeSpecialCharacters = (str: string, encode = true) => {\n  if (!encode) return str;\n\n  return str.replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#x27;');\n};\n\nfunction generateElementAttributesAsString<T>(\n  attrs: HTMLAttributes<T>,\n): string {\n  let res: string = '';\n\n  for (const [name, value] of Object.entries(attrs)) {\n    const attr = propToAttr(name);\n    const neu = value === undefined ? attr : `${attr}=\"${value}\"`;\n    if (neu && res) res += ' ';\n    res += neu;\n  }\n\n  return res;\n}\n\nconst generateTitleAsString = (\n  title: string,\n  attrs: TitleProps,\n  encode: boolean,\n) => {\n  let attrsStr = generateElementAttributesAsString(attrs);\n  if (attrsStr) attrsStr = ` ${attrsStr}`;\n\n  const flattenedTitle = flattenArray(title);\n\n  return `<title ${HELMET_ATTRIBUTE}=\"true\"${attrsStr}>${\n    encodeSpecialCharacters(flattenedTitle, encode)\n  }</title>`;\n};\n\nfunction generateTagsAsString<T>(\n  type: string,\n  tags: Array<HTMLAttributes<T>>,\n  encode: boolean,\n): string {\n  let res = '';\n\n  for (const tag of tags) {\n    let attributeHtml = '';\n\n    const entries = Object.entries(tag);\n    for (const [name, value] of entries) {\n      if (!(name === TAG_PROPERTIES.INNER_HTML as string\n        || name === TAG_PROPERTIES.CSS_TEXT as string)) {\n        const attrName = HTML_TAG_MAP[name] ?? name;\n\n        let attr: string;\n        if (value === undefined) attr = attrName;\n        else {\n          // Perhaps, if `value` is not a string we should just do\n          // \"attr = attrName\", as in the case just above. Playing\n          // it safe now, to avoid changes from the original code.\n          const valStr = typeof value === 'string' ? value : String(value);\n          attr = `${attrName}=\"${encodeSpecialCharacters(valStr, encode)}\"`;\n        }\n\n        if (attributeHtml) attributeHtml += ` ${attr}`;\n        else attributeHtml = attr;\n      }\n    }\n\n    const tagContent = (tag as ScriptProps).innerHTML ?? (tag as StyleProps).cssText ?? '';\n\n    const isSelfClosing = !SELF_CLOSING_TAGS.includes(type);\n\n    res += `<${type} ${HELMET_ATTRIBUTE}=\"true\" ${attributeHtml}${\n      isSelfClosing ? '/>' : `>${tagContent}</${type}>`\n    }`;\n  }\n\n  return res;\n}\n\n/**\n * Given a map of element attribute names & values it returns the corresponding\n * map of element properties & values (i.e. replacing some attribute names by\n * their corresponding property names).\n */\n\nfunction mapElementAttributesToProps<T>(\n  attributes: HTMLAttributes<T>,\n  ops: { addHelmetDataAttr?: boolean; addKey?: Key } = {},\n): Record<string, unknown> {\n  const res: Record<string, unknown> = {};\n  if (ops.addHelmetDataAttr) res[HELMET_ATTRIBUTE] = true;\n  if (ops.addKey !== undefined) res.key = ops.addKey;\n  for (const [attrName, value] of Object.entries(attributes)) {\n    const propName = REACT_TAG_MAP[attrName] ?? attrName;\n\n    switch (propName) {\n      // cssText and innerHTML props get a special treatment to avoid that React\n      // escapes their values.\n      case 'cssText':\n      case 'innerHTML':\n        res.dangerouslySetInnerHTML = { __html: value as unknown };\n        break;\n      default:\n        res[propName] = value;\n    }\n  }\n  return res;\n}\n\nfunction renderTitle(title: string, attrs: TitleProps): ReactNode {\n  // NOTE: Rendered as array to match legacy behavior.\n  return [\n    <title\n      key={title}\n      // TODO: Can we avoid violating the rule?\n      // eslint-disable-next-line react/jsx-props-no-spreading\n      {...mapElementAttributesToProps(attrs, { addHelmetDataAttr: true })}\n    >\n      {title}\n    </title>,\n  ];\n}\n\nfunction renderElement<T>(\n  type: string,\n  attrs: HTMLAttributes<T>,\n  key?: Key,\n): ReactNode {\n  return createElement(type, mapElementAttributesToProps(attrs, {\n    addHelmetDataAttr: true,\n    addKey: key,\n  }));\n}\n\nfunction renderElements<T>(\n  type: string,\n  attrs: Array<HTMLAttributes<T>>,\n): ReactNode[] {\n  const res: ReactNode[] = [];\n  for (let i = 0; i < attrs.length; ++i) {\n    res.push(renderElement(type, attrs[i]!, i));\n  }\n  return res;\n}\n\nexport function newServerState(heap: HelmetProviderHeap): HelmetServerState {\n  // TODO: Should this function to be attached to the heap itself?\n  const getState = () => {\n    // eslint-disable-next-line no-param-reassign\n    heap.state ??= calcAggregatedState(heap.helmets);\n    return heap.state;\n  };\n\n  return {\n    base: {\n      toComponent() {\n        const props = getState().base;\n        return props ? renderElements('base', [props]) : [];\n      },\n      toString() {\n        const s = getState();\n        return s.base ? generateTagsAsString('base', [s.base], s.encodeSpecialCharacters) : '';\n      },\n    },\n    bodyAttributes: {\n      toComponent() {\n        const props = getState().bodyAttributes;\n        return mapElementAttributesToProps(props ?? {});\n      },\n      toString() {\n        const props = getState().bodyAttributes;\n        return generateElementAttributesAsString(props ?? {});\n      },\n    },\n    htmlAttributes: {\n      toComponent() {\n        const props = getState().htmlAttributes;\n        return mapElementAttributesToProps(props ?? {});\n      },\n      toString() {\n        const props = getState().htmlAttributes;\n        return generateElementAttributesAsString(props ?? {});\n      },\n    },\n    link: {\n      toComponent() {\n        return renderElements('link', getState().links ?? []);\n      },\n      toString() {\n        const s = getState();\n        return generateTagsAsString('link', s.links ?? [], s.encodeSpecialCharacters);\n      },\n    },\n    meta: {\n      toComponent() {\n        return renderElements('meta', getState().meta ?? []);\n      },\n      toString() {\n        const s = getState();\n        return generateTagsAsString('meta', s.meta ?? [], s.encodeSpecialCharacters);\n      },\n    },\n    noscript: {\n      toComponent() {\n        return renderElements('noscript', getState().noscript ?? []);\n      },\n      toString() {\n        const s = getState();\n        return generateTagsAsString('noscript', s.noscript ?? [], s.encodeSpecialCharacters);\n      },\n    },\n    priority: {\n      toComponent() {\n        const s = getState();\n        return [\n          ...renderElements('meta', s.priority?.meta ?? []),\n          ...renderElements('link', s.priority?.links ?? []),\n          ...renderElements('script', s.priority?.script ?? []),\n        ];\n      },\n      toString() {\n        const s = getState();\n        const meta = generateTagsAsString('meta', s.priority?.meta ?? [], s.encodeSpecialCharacters);\n        const link = generateTagsAsString('link', s.priority?.links ?? [], s.encodeSpecialCharacters);\n        const script = generateTagsAsString('script', s.priority?.script ?? [], s.encodeSpecialCharacters);\n\n        let res = meta;\n        if (link) {\n          if (res) res += ' ';\n          res += link;\n        }\n        if (script) {\n          if (res) res += ' ';\n          res += script;\n        }\n\n        return res;\n      },\n    },\n    script: {\n      toComponent() {\n        return renderElements('script', getState().script ?? []);\n      },\n      toString() {\n        const s = getState();\n        return generateTagsAsString('script', s.script ?? [], s.encodeSpecialCharacters);\n      },\n    },\n    style: {\n      toComponent() {\n        return renderElements('style', getState().style ?? []);\n      },\n      toString() {\n        const s = getState();\n        return generateTagsAsString('style', s.style ?? [], s.encodeSpecialCharacters);\n      },\n    },\n    title: {\n      toComponent(): ReactNode {\n        const s = getState();\n        return renderTitle(s.title ?? '', s.titleAttributes ?? {});\n      },\n      toString() {\n        const s = getState();\n        return generateTitleAsString(s.title ?? '', s.titleAttributes ?? {}, s.encodeSpecialCharacters);\n      },\n    },\n  };\n}\n", "import {\n  HTML_TAG_MAP,\n  TAG_NAMES,\n  TAG_PROPERTIES,\n  SEO_PRIORITY_TAGS,\n} from './constants';\n\nimport type {\n  AggregatedState,\n  BaseProps,\n  HelmetPropArrays,\n  HelmetPropBooleans,\n  HelmetPropObjects,\n  HelmetProps,\n  LinkProps,\n  MetaProps,\n  PropArrayItem,\n  RegisteredHelmetPropsArray,\n  ScriptProps,\n} from './types';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype PropList = Record<string, any>;\n\ntype AttributeList = string[];\n\ntype SeenTags<T extends keyof HelmetPropArrays> = {\n  [key in keyof PropArrayItem<T>]?: Record<string, boolean>\n};\n\ntype MatchProps = Record<string, string | AttributeList>;\n\n/**\n * Finds the last object in the given array of registered props,\n * that has the specified prop defined, and returns the value of\n * that prop in that object. Returns `undefined` if no prop object\n * has that prop defined.\n */\nfunction getInnermostProperty<T extends keyof HelmetProps>(\n  props: RegisteredHelmetPropsArray,\n  propName: T,\n): HelmetProps[T] | undefined {\n  for (let i = props.length - 1; i >= 0; --i) {\n    const value = props[i]![1][propName];\n    if (value !== undefined) return value;\n  }\n  return undefined;\n}\n\nexport function getTitleFromPropsList(\n  props: RegisteredHelmetPropsArray,\n): string | undefined {\n  let innermostTitle = getInnermostProperty(props, TAG_NAMES.TITLE);\n\n  const innermostTemplate = getInnermostProperty(\n    props,\n    'titleTemplate',\n  );\n\n  if (Array.isArray(innermostTitle)) {\n    innermostTitle = innermostTitle.join('');\n  }\n  if (innermostTemplate && innermostTitle) {\n    // use function arg to avoid need to escape $ characters\n    return innermostTemplate.replace(/%s/g, () => innermostTitle);\n  }\n\n  const innermostDefaultTitle = getInnermostProperty(\n    props,\n    'defaultTitle',\n  );\n\n  // NOTE: We really want || here to match legacy behavior, where default title\n  // was applied also when the given title was an empty string.\n  // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n  return (innermostTitle || innermostDefaultTitle) ?? undefined;\n}\n\n/**\n * Merges together attributes provided for the same element by different Helmet\n * instances. Attributes provided by later registered Helmet instances overwrite\n * the same attributes provided by the earlier registered instances.\n */\nexport function mergeAttributes<T extends keyof HelmetPropObjects>(\n  element: T,\n  props: RegisteredHelmetPropsArray,\n): HelmetProps[T] {\n  const res: HelmetProps[T] = {};\n  for (const item of props) {\n    const attrs = item[1][element];\n    if (attrs) Object.assign(res, attrs);\n  }\n  return res;\n}\n\n/**\n * Finds the latest registered Helmet instance with `base` props provided,\n * and with its `href` value set, and returns those `base` props.\n * NOTE: Based on the legacy getBaseTagFromPropsList().\n */\nexport function aggregateBaseProps(\n  props: RegisteredHelmetPropsArray,\n): BaseProps | undefined {\n  for (let i = props.length - 1; i >= 0; --i) {\n    const res = props[i]![1].base;\n    if (res?.href) return res;\n  }\n  return undefined;\n}\n\n/**\n * Determines the primary key in the given `props` object, accoding to the given\n * array of valid primary keys for the kind of props object.\n * TODO: Rather than passing an array of primaryProps around, it might be more\n * simple to just have a dedicated function for each possible kind of that\n * object.\n */\nfunction getPrimaryProp<T extends keyof HelmetPropArrays>(\n  props: PropArrayItem<T>,\n  primaryProps: Array<keyof PropArrayItem<T>>,\n): keyof PropArrayItem<T> | null {\n  // Looks up for the \"primary attribute\" key.\n  let primaryAttributeKey: keyof PropArrayItem<T> | undefined;\n\n  // TODO: Perhaps also check that the value of attribute being selected\n  // as primary is actually defined? Right now, it implicitly assumes that\n  // in such case the attribute is just not present as a key in `props`.\n  for (const keyString of Object.keys(props)) {\n    const key = keyString as keyof PropArrayItem<T>;\n\n    // Special rule with link tags, since rel and href are both primary tags,\n    // rel takes priority\n    if (primaryProps.includes(key)\n      && !(\n        primaryAttributeKey === TAG_PROPERTIES.REL\n        && (props[primaryAttributeKey] as string).toLowerCase() === 'canonical'\n      )\n      && !(\n        key === TAG_PROPERTIES.REL\n        && (props[key] as string).toLowerCase() === 'stylesheet'\n      )\n    ) primaryAttributeKey = key;\n\n    // Special case for innerHTML which doesn't work lowercased\n    if (\n      primaryProps.includes(key)\n      && (key === TAG_PROPERTIES.INNER_HTML\n        || key === TAG_PROPERTIES.CSS_TEXT\n        || key === TAG_PROPERTIES.ITEM_PROP)\n    ) primaryAttributeKey = key;\n  }\n\n  return primaryAttributeKey ?? null;\n}\n\nexport function getTagsFromPropsList<T extends keyof HelmetPropArrays>(\n  tagName: T,\n  primaryAttributes: Array<keyof PropArrayItem<T>>,\n  propsArray: RegisteredHelmetPropsArray,\n): HelmetPropArrays[T] {\n  // Calculate list of tags, giving priority innermost component\n  // (end of the propslist)\n  const approvedSeenTags: SeenTags<T> = {};\n\n  // TODO: Well, this is a touch one to refactor, while ensuring it does not\n  // change any behavior aspect... let's stick to the legacy implementation,\n  // with minimal updates, for now, then refactor it later.\n  return propsArray.map(([, props]) => props)\n    .filter((props) => {\n      if (Array.isArray(props[tagName])) {\n        return true;\n      }\n      if (typeof props[tagName] !== 'undefined') {\n        // eslint-disable-next-line no-console\n        console.warn(\n          `Helmet: ${tagName} should be of type \"Array\". Instead found type \"${typeof props[\n            tagName\n          ]}\"`,\n        );\n      }\n      return false;\n    })\n    .map((props) => props[tagName])\n    .reverse()\n\n    // From last to first.\n    .reduce<Array<PropArrayItem<T>>>((approvedTags, instanceTags) => {\n      const instanceSeenTags: SeenTags<T> = {};\n\n      instanceTags!.filter((tag: PropArrayItem<T>) => {\n        const primaryAttributeKey = getPrimaryProp(tag, primaryAttributes);\n\n        if (!primaryAttributeKey || !tag[primaryAttributeKey]) {\n          return false;\n        }\n\n        const value = (tag[primaryAttributeKey] as string).toLowerCase();\n\n        if (!approvedSeenTags[primaryAttributeKey]) {\n          approvedSeenTags[primaryAttributeKey] = {};\n        }\n\n        if (!instanceSeenTags[primaryAttributeKey]) {\n          instanceSeenTags[primaryAttributeKey] = {};\n        }\n\n        // essentially we collect every item that haven't been seen so far?\n\n        if (!approvedSeenTags[primaryAttributeKey][value]) {\n          instanceSeenTags[primaryAttributeKey][value] = true;\n          return true;\n        }\n\n        return false;\n      }).reverse()\n\n        // so approved tags are accumulated from last to first\n        .forEach((tag: PropArrayItem<T>) => approvedTags.push(tag));\n\n      // Update seen tags with tags from this instance\n      const keys = Object.keys(instanceSeenTags) as\n        Array<keyof PropArrayItem<T>>;\n\n      for (const attributeKey of keys) {\n        const tagUnion = {\n          ...approvedSeenTags[attributeKey],\n          ...instanceSeenTags[attributeKey],\n        };\n\n        approvedSeenTags[attributeKey] = tagUnion;\n      }\n\n      return approvedTags;\n    }, [])\n\n    // then reversed back to the from first-to-last order.\n    .reverse() as HelmetPropArrays[T];\n}\n\nfunction getAnyTrueFromPropsArray<T extends keyof HelmetPropBooleans>(\n  propsArray: RegisteredHelmetPropsArray,\n  propName: T,\n): boolean {\n  for (const [, props] of propsArray) {\n    if (props[propName]) return true;\n  }\n  return false;\n}\n\nexport function flattenArray(possibleArray: string[] | string): string {\n  return Array.isArray(possibleArray) ? possibleArray.join('') : possibleArray;\n}\n\nfunction checkIfPropsMatch<T extends keyof HelmetPropArrays>(\n  props: PropArrayItem<T>,\n  toMatch: MatchProps,\n) {\n  for (const key of Object.keys(props)) {\n    // e.g. if rel exists in the list of allowed props [amphtml, alternate, etc]\n    // TODO: Do a better typing job here.\n    if (toMatch[key]?.includes(\n      props[key as keyof PropArrayItem<T>] as unknown as string,\n    )) return true;\n  }\n  return false;\n}\n\nexport function prioritizer<T extends keyof HelmetPropArrays>(\n  propsArray: HelmetPropArrays[T],\n  propsToMatch: MatchProps,\n): {\n  default: Array<PropArrayItem<T>>;\n  priority: Array<PropArrayItem<T>>;\n} {\n  const res = {\n    default: Array<PropArrayItem<T>>(),\n    priority: Array<PropArrayItem<T>>(),\n  };\n\n  if (propsArray) {\n    for (const props of propsArray) {\n      if (checkIfPropsMatch(props, propsToMatch)) {\n        res.priority.push(props);\n      } else {\n        res.default.push(props);\n      }\n    }\n  }\n\n  return res;\n}\n\n// TODO: Perhaps, we better destruct the `obj` first, and then create the result\n// not including the key altogether?\nexport const without = (obj: PropList, key: string): PropList => ({\n  ...obj,\n  [key]: undefined,\n});\n\ntype UnknownObject = Record<number | string | symbol, unknown>;\n\n/**\n * Clones given props object deep enough to make it safe to push new items\n * to its array values, and re-assign its non-array values, without a risk\n * to mutate any externally owned objects.\n */\nexport function cloneProps(props: HelmetProps): HelmetProps {\n  const res: UnknownObject = {};\n  for (const [key, value] of Object.entries(props)) {\n    res[key] = Array.isArray(value) ? value.slice() : value;\n  }\n  return res;\n}\n\n/**\n * Merges `source` props into `target`, mutating the `target` object.\n */\nexport function mergeProps(target: HelmetProps, source: HelmetProps): void {\n  const tgt = target as UnknownObject;\n  for (const [key, srcValue] of Object.entries(source)) {\n    if (Array.isArray(srcValue)) {\n      const tgtValue = tgt[key] as unknown[] | undefined;\n      tgt[key] = tgtValue ? tgtValue.concat(srcValue) : srcValue;\n    } else tgt[key] = srcValue;\n  }\n}\n\n/**\n * Adds given item to the specified prop array inside `target`.\n * It mutates the target.\n */\nexport function pushToPropArray<K extends keyof HelmetPropArrays>(\n  target: HelmetProps,\n  array: K,\n  item: Exclude<HelmetPropArrays[K], undefined>[number],\n): void {\n  type A = Array<typeof item>;\n  const tgt = target[array] as A | undefined;\n  if (tgt) tgt.push(item);\n\n  // eslint-disable-next-line no-param-reassign\n  else (target[array] as A) = [item];\n}\n\nexport function calcAggregatedState(\n  props: RegisteredHelmetPropsArray,\n): AggregatedState {\n  let links = getTagsFromPropsList(\n    TAG_NAMES.LINK,\n    [TAG_PROPERTIES.REL, TAG_PROPERTIES.HREF],\n    props,\n  );\n  let meta = getTagsFromPropsList(\n    'meta',\n    [\n      // NOTE: In the legacy version \"charSet\", \"httpEquiv\", and \"itemProp\"\n      // were given as HTML attributes: charset, http-equiv, itemprop.\n      // I believe, it is already fine to replace them here now, but\n      // let's be vigilant.\n      TAG_PROPERTIES.NAME,\n      'charSet',\n      'httpEquiv',\n      TAG_PROPERTIES.PROPERTY,\n      'itemProp',\n    ],\n    props,\n  );\n  let script = getTagsFromPropsList(\n    'script',\n    [TAG_PROPERTIES.SRC, TAG_PROPERTIES.INNER_HTML],\n    props,\n  );\n\n  const prioritizeSeoTags = getAnyTrueFromPropsArray(props, 'prioritizeSeoTags');\n\n  let priority: {\n    links: LinkProps[] | undefined;\n    meta: MetaProps[] | undefined;\n    script: ScriptProps[] | undefined;\n  } | undefined;\n\n  if (prioritizeSeoTags) {\n    const linkP = prioritizer<'link'>(links, SEO_PRIORITY_TAGS.link);\n    links = linkP.default;\n\n    const metaP = prioritizer<'meta'>(meta, SEO_PRIORITY_TAGS.meta);\n    meta = metaP.default;\n\n    const scriptP = prioritizer<'script'>(script, SEO_PRIORITY_TAGS.script);\n    script = scriptP.default;\n\n    priority = {\n      links: linkP.priority,\n      meta: metaP.priority,\n      script: scriptP.priority,\n    };\n  }\n\n  return {\n    base: aggregateBaseProps(props),\n    bodyAttributes: mergeAttributes('bodyAttributes', props),\n    defer: getInnermostProperty(props, 'defer'),\n    encodeSpecialCharacters: getInnermostProperty(props, 'encodeSpecialCharacters') ?? true,\n    htmlAttributes: mergeAttributes('htmlAttributes', props),\n    links,\n    meta,\n    noscript: getTagsFromPropsList(\n      'noscript',\n      [TAG_PROPERTIES.INNER_HTML],\n      props,\n    ),\n    onChangeClientState: getInnermostProperty(props, 'onChangeClientState'),\n    priority,\n    script,\n    style: getTagsFromPropsList(\n      'style',\n      [TAG_PROPERTIES.CSS_TEXT],\n      props,\n    ),\n    title: getTitleFromPropsList(props),\n    titleAttributes: mergeAttributes('titleAttributes', props),\n  };\n}\n\nexport function propToAttr(prop: string): string {\n  return HTML_TAG_MAP[prop] ?? prop;\n}\n", "import {\n  HELMET_ATTRIBUTE,\n  HTML_TAG_MAP,\n  TAG_NAMES,\n  TAG_PROPERTIES,\n} from './constants';\n\nimport type {\n  AggregatedState,\n  BodyProps,\n  HelmetChildProps,\n  HelmetTags,\n  HtmlProps,\n  StateUpdate,\n} from './types';\n\nimport { flattenArray } from './utils';\n\ntype TagUpdates = {\n  allTags: HTMLElement[];\n  oldTags: HTMLElement[];\n  newTags: HTMLElement[];\n};\n\ntype TagUpdateList = Record<string, TagUpdates>;\n\n/**\n * Replaces HTML elements previously added to the DOM's head by React Helmet\n * by the set of given elements (tags). For any given element that matches\n * exactly an element already present in the head no actual DOM modification\n * happens, it just keeps already present element. Returns arrays of newly\n * added (newTags) and removed (oldTags) elements.\n */\nfunction updateTags(type: string, tags: HelmetChildProps[]) {\n  // TODO: Do we really need the fallback here? document.head is supposed to be\n  // always defined.\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  const headElement = document.head || document.querySelector(TAG_NAMES.HEAD);\n\n  const tagNodes = headElement.querySelectorAll<HTMLElement>(`${type}[${HELMET_ATTRIBUTE}]`);\n  const allTags: HTMLElement[] = [];\n  const oldTags: HTMLElement[] = [...tagNodes];\n  const newTags: HTMLElement[] = [];\n\n  for (const tag of tags) {\n    const newElement = document.createElement(type);\n\n    // TODO: Well, the typing within this block is bad, and should be improved.\n    for (const [key, value] of Object.entries(tag)) {\n      // TODO: Revisit layer.\n      // eslint-disable-next-line prefer-object-has-own\n      if (Object.prototype.hasOwnProperty.call(tag, key)) {\n        const name = HTML_TAG_MAP[key] ?? key;\n        if (name as TAG_PROPERTIES === TAG_PROPERTIES.INNER_HTML) {\n          newElement.innerHTML = value as string;\n        } else if (name as TAG_PROPERTIES === TAG_PROPERTIES.CSS_TEXT) {\n          // TODO: Not sure when this is true?\n          // @ts-expect-error \"pre-existing\"\n          if (newElement.styleSheet) {\n            // @ts-expect-error \"pre-existing\"\n            (newElement.styleSheet as CSSStyleDeclaration).cssText = (\n              tag as CSSStyleDeclaration).cssText;\n          } else {\n            newElement.appendChild(document.createTextNode(\n              (tag as CSSStyleDeclaration).cssText,\n            ));\n          }\n        } else {\n          newElement.setAttribute(name, (value as string | undefined) ?? '');\n        }\n      }\n    }\n\n    newElement.setAttribute(HELMET_ATTRIBUTE, 'true');\n\n    const attrs = {} as HTMLElement;\n    for (const { name, value } of newElement.attributes) {\n      (attrs[name as keyof HTMLElement] as unknown) = value;\n    }\n    allTags.push(attrs);\n\n    // Remove a duplicate tag from domTagstoRemove, so it isn't cleared.\n    for (let i = 0; ; ++i) {\n      if (newElement.isEqualNode(oldTags[i]!)) {\n        oldTags.splice(i, 1);\n        break;\n      }\n      if (i >= oldTags.length) {\n        newTags.push(newElement);\n        break;\n      }\n    }\n  }\n\n  oldTags.forEach((tag: Node) => tag.parentNode?.removeChild(tag));\n  newTags.forEach((tag) => headElement.appendChild(tag));\n\n  // TODO: Do we really need this return value anywhere? Especially `oldTags`\n  // that have been removed from DOM already?\n  return {\n    allTags,\n    newTags,\n    oldTags,\n  };\n}\n\nfunction updateAttributes(tagName: string, props: BodyProps | HtmlProps) {\n  const [elementTag] = document.getElementsByTagName(tagName);\n\n  if (!elementTag) {\n    return;\n  }\n\n  const helmetAttributeString = elementTag.getAttribute(HELMET_ATTRIBUTE);\n  const helmetAttributes = helmetAttributeString ? helmetAttributeString.split(',') : [];\n  const attributesToRemove = [...helmetAttributes];\n\n  const attributeKeys: string[] = [];\n  for (const prop of Object.keys(props)) {\n    // TODO: See a comment below.\n    attributeKeys.push(HTML_TAG_MAP[prop] ?? prop);\n  }\n\n  for (const [key, value] of Object.entries(props)) {\n    // TODO: Get rid of the mapping later. It is not really needed, as HTML\n    // attribute names are case-insensitive. However, our related logic may\n    // still be case dependent - we should be careful about it.\n    const attr = HTML_TAG_MAP[key] ?? key;\n    if (elementTag.getAttribute(attr) !== value) {\n      // TODO: That ?? '' piece is here to keep the legacy behavior for now,\n      // I guess later we should prefer to consider attrbiutes with \"undefined\"\n      // value as not set.\n      elementTag.setAttribute(attr, value as string | undefined ?? '');\n    }\n\n    if (!helmetAttributes.includes(attr)) {\n      helmetAttributes.push(attr);\n    }\n\n    const indexToSave = attributesToRemove.indexOf(attr);\n    if (indexToSave !== -1) {\n      attributesToRemove.splice(indexToSave, 1);\n    }\n  }\n\n  for (let i = attributesToRemove.length - 1; i >= 0; i -= 1) {\n    elementTag.removeAttribute(attributesToRemove[i]!);\n  }\n\n  if (helmetAttributes.length === attributesToRemove.length) {\n    elementTag.removeAttribute(HELMET_ATTRIBUTE);\n  } else if (elementTag.getAttribute(HELMET_ATTRIBUTE) !== attributeKeys.join(',')) {\n    elementTag.setAttribute(HELMET_ATTRIBUTE, attributeKeys.join(','));\n  }\n}\n\nfunction updateTitle(\n  title: string | undefined,\n  attributes: BodyProps | HtmlProps,\n) {\n  if (title !== undefined && document.title !== title) {\n    document.title = flattenArray(title);\n  }\n\n  updateAttributes(TAG_NAMES.TITLE, attributes);\n}\n\nexport function commitTagChanges(\n  newState: AggregatedState,\n  firstRender: boolean,\n): void {\n  const {\n    base,\n    bodyAttributes,\n    defer,\n    htmlAttributes,\n    links,\n    meta,\n    noscript,\n    onChangeClientState,\n    script,\n    style,\n    title,\n    titleAttributes,\n  } = newState;\n  updateAttributes(TAG_NAMES.BODY, bodyAttributes ?? {});\n  updateAttributes(TAG_NAMES.HTML, htmlAttributes ?? {});\n\n  updateTitle(title, titleAttributes!);\n\n  const tagUpdates: TagUpdateList = {\n    baseTag: updateTags(TAG_NAMES.BASE, base ? [base] : []),\n    linkTags: updateTags(TAG_NAMES.LINK, links ?? []),\n    metaTags: updateTags(TAG_NAMES.META, meta ?? []),\n    noscriptTags: updateTags(TAG_NAMES.NOSCRIPT, noscript ?? []),\n    scriptTags: updateTags(TAG_NAMES.SCRIPT, script ?? []),\n    styleTags: updateTags(TAG_NAMES.STYLE, style ?? []),\n  };\n\n  const resultTags: StateUpdate = {\n    baseTag: [],\n    bodyAttributes: {},\n    defer: defer ?? false,\n    htmlAttributes: {},\n    linkTags: [],\n    metaTags: [],\n    noscriptTags: [],\n    onChangeClientState: onChangeClientState ?? (() => undefined),\n    scriptTags: [],\n    styleTags: [],\n    title: title ?? '',\n    titleAttributes: {},\n  };\n\n  const addedTags: Partial<HelmetTags> = {};\n  const removedTags: Partial<HelmetTags> = {};\n\n  Object.keys(tagUpdates).forEach((tagType) => {\n    const { allTags, newTags, oldTags } = tagUpdates[tagType]!;\n\n    (resultTags[tagType as keyof HelmetTags] as HTMLElement[]) = allTags;\n\n    if (newTags.length) {\n      (addedTags[tagType as keyof HelmetTags] as HTMLElement[]) = newTags;\n    }\n    if (oldTags.length) {\n      (removedTags[tagType as keyof HelmetTags] as HTMLElement[])\n        = tagUpdates[tagType]!.oldTags;\n    }\n  });\n\n  if (firstRender\n    || Object.keys(addedTags).length\n    || Object.keys(removedTags).length\n  ) {\n    onChangeClientState?.(resultTags, addedTags, removedTags);\n  }\n}\n", "import {\n  type Context as ContextT,\n  type FunctionComponent,\n  type ReactNode,\n  createContext,\n  useMemo,\n} from 'react';\n\nimport Helmet from './Helmet';\n\ntype PropsT = {\n  children?: ReactNode;\n  description: string;\n  extraMetaTags?: Array<{\n    content: string;\n    name: string;\n  }>;\n  image?: string;\n  siteName?: string;\n  socialDescription?: string;\n  socialTitle?: string;\n  title: string;\n  url?: string;\n};\n\nconst Context = createContext<PropsT>({\n  description: '',\n  title: '',\n});\n\n/**\n * Auxiliary wrapper around \"react-helmet\", which helps to inject meta tags\n * (page title, a brief content description, and social media thumbnails) into\n * generated pages.\n */\nconst MetaTags: FunctionComponent<PropsT> & {\n  Context: ContextT<PropsT>;\n} = ({\n  children,\n  description,\n  extraMetaTags,\n  image,\n  siteName,\n  socialDescription,\n  socialTitle,\n  title,\n  url,\n}) => {\n  // NOTE: I guess, in this very case, we should prefer title and description\n  // also to empty social title and decscription?\n  /* eslint-disable @typescript-eslint/prefer-nullish-coalescing */\n  const socTitle = socialTitle || title;\n  const socDesc = socialDescription || description;\n  /* eslint-enable @typescript-eslint/prefer-nullish-coalescing */\n\n  const context = useMemo(() => ({\n    description,\n    image,\n    siteName,\n    socialDescription,\n    socialTitle,\n    title,\n    url,\n  }), [\n    description,\n    image,\n    siteName,\n    socialDescription,\n    socialTitle,\n    title,\n    url,\n  ]);\n\n  const extra: ReactNode[] = [];\n  if (extraMetaTags?.length) {\n    for (let i = 0; i < extraMetaTags.length; ++i) {\n      const { content, name } = extraMetaTags[i]!;\n      extra.push(\n        <meta\n          content={content}\n          key={`extra-meta-tag-${i}`}\n          name={name}\n        />,\n      );\n    }\n  }\n\n  return (\n    <>\n      <Helmet>\n        {/* General tags. */}\n        <title>\n          {title}\n        </title>\n        <meta content={description} name=\"description\" />\n\n        {/* Twitter cards. */}\n        <meta content=\"summary_large_image\" name=\"twitter:card\" />\n        <meta content={socTitle} name=\"twitter:title\" />\n        <meta content={socDesc} name=\"twitter:description\" />\n        { image ? <meta content={image} name=\"twitter:image\" /> : null }\n        {\n          siteName\n            ? <meta content={`@${siteName}`} name=\"twitter:site\" />\n            : null\n        }\n\n        {/* Open Graph data. */}\n        <meta content={socTitle} name=\"og:title\" />\n        { image ? <meta content={image} name=\"og:image\" /> : null }\n        { image ? <meta content={socTitle} name=\"og:image:alt\" /> : null }\n        <meta content={socDesc} name=\"og:description\" />\n        {\n          siteName ? <meta content={siteName} name=\"og:sitename\" /> : null\n        }\n        { url ? <meta content={url} name=\"og:url\" /> : null }\n        {extra}\n      </Helmet>\n      {\n        children ? (\n          <Context value={context}>\n            {children}\n          </Context>\n        ) : null\n      }\n    </>\n  );\n};\n\nMetaTags.Context = Context;\n\nexport default MetaTags;\n"],
  "mappings": "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",
  "names": ["import_react", "TAG_PROPERTIES", "ATTRIBUTE_NAMES", "TAG_NAMES", "SEO_PRIORITY_TAGS", "link", "rel", "meta", "charset", "name", "property", "script", "type", "VALID_TAG_NAMES", "Object", "values", "REACT_TAG_MAP", "accesskey", "class", "contenteditable", "contextmenu", "itemprop", "tabindex", "HTML_TAG_MAP", "res", "key", "value", "entries", "HELMET_ATTRIBUTE", "IS_DOM_ENVIRONMENT", "window", "document", "createElement", "import_react", "getInnermostProperty", "props", "propName", "i", "length", "value", "undefined", "getTitleFromPropsList", "innermostTitle", "TAG_NAMES", "TITLE", "innermostTemplate", "Array", "isArray", "join", "replace", "innermostDefaultTitle", "mergeAttributes", "element", "res", "item", "attrs", "Object", "assign", "aggregateBaseProps", "base", "href", "getPrimaryProp", "primaryProps", "primaryAttributeKey", "keyString", "keys", "key", "includes", "TAG_PROPERTIES", "REL", "toLowerCase", "INNER_HTML", "CSS_TEXT", "ITEM_PROP", "getTagsFromPropsList", "tagName", "primaryAttributes", "propsArray", "approvedSeenTags", "map", "filter", "console", "warn", "reverse", "reduce", "approvedTags", "instanceTags", "instanceSeenTags", "tag", "forEach", "push", "attributeKey", "tagUnion", "getAnyTrueFromPropsArray", "flattenArray", "possibleArray", "checkIfPropsMatch", "toMatch", "prioritizer", "propsToMatch", "default", "priority", "cloneProps", "props", "res", "key", "value", "Object", "entries", "Array", "isArray", "slice", "mergeProps", "target", "source", "tgt", "srcValue", "tgtValue", "concat", "pushToPropArray", "array", "item", "push", "calcAggregatedState", "links", "getTagsFromPropsList", "TAG_NAMES", "LINK", "TAG_PROPERTIES", "REL", "HREF", "meta", "NAME", "PROPERTY", "script", "SRC", "INNER_HTML", "prioritizeSeoTags", "getAnyTrueFromPropsArray", "priority", "linkP", "prioritizer", "SEO_PRIORITY_TAGS", "link", "default", "metaP", "scriptP", "base", "aggregateBaseProps", "bodyAttributes", "mergeAttributes", "defer", "getInnermostProperty", "encodeSpecialCharacters", "htmlAttributes", "noscript", "onChangeClientState", "style", "CSS_TEXT", "title", "getTitleFromPropsList", "titleAttributes", "propToAttr", "prop", "HTML_TAG_MAP", "SELF_CLOSING_TAGS", "TAG_NAMES", "NOSCRIPT", "SCRIPT", "STYLE", "encodeSpecialCharacters", "str", "encode", "replace", "generateElementAttributesAsString", "attrs", "res", "name", "value", "Object", "entries", "attr", "propToAttr", "neu", "undefined", "generateTitleAsString", "title", "attrsStr", "flattenedTitle", "flattenArray", "HELMET_ATTRIBUTE", "generateTagsAsString", "type", "tags", "tag", "attributeHtml", "TAG_PROPERTIES", "INNER_HTML", "CSS_TEXT", "attrName", "HTML_TAG_MAP", "valStr", "String", "tagContent", "innerHTML", "cssText", "isSelfClosing", "includes", "mapElementAttributesToProps", "attributes", "ops", "addHelmetDataAttr", "addKey", "key", "propName", "REACT_TAG_MAP", "dangerouslySetInnerHTML", "__html", "renderTitle", "_jsx", "children", "renderElement", "createElement", "renderElements", "i", "length", "push", "newServerState", "heap", "getState", "state", "calcAggregatedState", "helmets", "base", "toComponent", "props", "toString", "s", "bodyAttributes", "htmlAttributes", "link", "links", "meta", "noscript", "priority", "script", "style", "titleAttributes", "updateTags", "type", "tags", "headElement", "document", "head", "querySelector", "TAG_NAMES", "HEAD", "tagNodes", "querySelectorAll", "HELMET_ATTRIBUTE", "allTags", "oldTags", "newTags", "tag", "newElement", "createElement", "key", "value", "Object", "entries", "prototype", "hasOwnProperty", "call", "name", "HTML_TAG_MAP", "TAG_PROPERTIES", "INNER_HTML", "innerHTML", "CSS_TEXT", "styleSheet", "cssText", "appendChild", "createTextNode", "setAttribute", "attrs", "attributes", "push", "i", "isEqualNode", "splice", "length", "forEach", "parentNode", "removeChild", "updateAttributes", "tagName", "props", "elementTag", "getElementsByTagName", "helmetAttributeString", "getAttribute", "helmetAttributes", "split", "attributesToRemove", "attributeKeys", "prop", "keys", "attr", "includes", "indexToSave", "indexOf", "removeAttribute", "join", "updateTitle", "title", "undefined", "flattenArray", "TITLE", "commitTagChanges", "newState", "firstRender", "base", "bodyAttributes", "defer", "htmlAttributes", "links", "meta", "noscript", "onChangeClientState", "script", "style", "titleAttributes", "BODY", "HTML", "tagUpdates", "baseTag", "BASE", "linkTags", "LINK", "metaTags", "META", "noscriptTags", "NOSCRIPT", "scriptTags", "SCRIPT", "styleTags", "STYLE", "resultTags", "addedTags", "removedTags", "tagType", "import_jsx_runtime", "Context", "createContext", "undefined", "HelmetProvider", "children", "context", "current", "heap", "useRef", "firstRender", "helmets", "state", "contextValueRef", "clientApply", "IS_DOM_ENVIRONMENT", "calcAggregatedState", "defer", "nextAnimFrameId", "requestAnimationFrame", "commitTagChanges", "cancelAnimationFrame", "update", "id", "props", "idx", "findIndex", "item", "splice", "push", "helmet", "serverState", "newServerState", "_jsx", "value", "assertChildType", "childType", "nestedChildren", "Error", "VALID_TAG_NAMES", "includes", "join", "Array", "isArray", "getPropName", "key", "res", "REACT_TAG_MAP", "console", "warn", "reduceChildrenAndProps", "props", "cloneProps", "item", "Object", "values", "it", "keys", "p", "Children", "forEach", "children", "child", "undefined", "childProps", "value", "entries", "type", "toString", "assertStringChild", "child2", "error", "TAG_NAMES", "BASE", "base", "BODY", "bodyAttributes", "FRAGMENT", "mergeProps", "HTML", "htmlAttributes", "LINK", "META", "pushToPropArray", "NOSCRIPT", "SCRIPT", "innerHTML", "STYLE", "cssText", "TITLE", "titleAttributes", "title", "HEAD", "bad", "Helmet", "context", "use", "Context", "id", "useId", "update", "useEffect", "clientApply", "import_react", "import_jsx_runtime", "Context", "createContext", "description", "title", "MetaTags", "children", "extraMetaTags", "image", "siteName", "socialDescription", "socialTitle", "url", "socTitle", "socDesc", "context", "useMemo", "extra", "length", "i", "content", "name", "push", "_jsx", "_jsxs", "_Fragment", "Helmet", "value"]
}
